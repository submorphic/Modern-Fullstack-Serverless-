
# Chapter 9, Building Offline Apps with Amplify DataStore

Amplify supports another type of API for interacting with AppSync: Amplify DataStore. DataStore has a different approach than a traditional GraphQL API.

Instead of interacting with the GraphQL API itself, using queries and mutations, DataStore introduces a client-side SDK that allows you to write to and read from a local store and persists this data locally using the local storage engine of the platform you are working with (i.e., IndexDB for web and SQLite for native iOS and Android).

DataStore then automatically syncs the local data to the GraphQL backend for you as updates are made both locally and remotely.

Using the DataStore SDK, you then only have to perform the
operations like save, update, and delete, writing directly to DataStore
itself. DataStore handles everything else for you: it syncs your data to
the cloud when you have an internet connection, and if you’re not
online, will queue it for the next time you’re connected.

## About Amplify DataStore

Amplify DataStore is a combination of the following things:

AppSync GraphQL API.

Local storage repository and syncing engine that also persists data offline.

Client-side SDK for interacting with the local storage repository.

Special sync-enabled GraphQL resolvers (generated by the Amplify CLI) that enable sophisticated conflict detection and conflict resolution on the server.

### Amplify DataStore Overview

When getting started with DataStore, you still create the API as we have done in past chapters. The main difference is, when creating the
API, you will enable conflict detection in the advanced settings of the CLI flow.

From there, to enable DataStore on the client, we need to create
models for DataStore to use to interact with the storage repository.

This can easily be done by just using the GraphQL schema you
already have and running a build command—amplify codegen
models—from the CLI.


Now, you are all set up and can begin interacting with DataStore.

### Amplify DataStore Operations

To interact with the Store, first import the DataStore API from Amplify and the Model you’d like to use. From there, you can perform actions against the store.


#### Operations & Commands

Import the model and DataStore
API

```javascript

  import { DataStore } from '@aws-amplify/datastore';
  import { Message} from './models'; 

```

Saving data

```javascript
await DataStore.save(
  new Message({
    title: 'Hello World',
    sender: 'Chris'
  })
))

```

Reading data 

```javascript 
const posts = await DataStore.query(Post); 
```

Updating data 

```javascript

const message = await DataStore.query(Message, '123')

await DataStore.save(
  Post.copyOf(message, updated => { updated.title = 'My new title'})
)

```

Observing/subscribing to changes in data for real-time functionality

```javascript

 const subscription = DataStore.observe(Message).subscribe(msg => {
    console.log(message.model, message.opType, message.element)
});
```

DataStore Predicates
You can apply predicate filters against the DataStore using the fields
defined on your GraphQL type along with the following conditions
supported by DynamoDB:
```
Strings: eq | ne | le | lt | ge | gt | contains | notContains | beginsWith | between

Numbers: eq | ne | le | lt | ge | gt | between

Lists: contains | notContains

```

For example, if you wanted a list of all messages that have a title
that includes “Hello”:

```javascript

const messages = await DataStore.query(Message, m => m.title('contains', 'Hello'))

```

You can also chain multiple predicates into a single operation:

```js
const message = await DataStore .query(Message, m => m.title('contains', 'Hello').sender('eq', 'Chris'))
```

These predicates enable you to have many ways to retrieve different selection sets from your local data. Instead of retrieving the entire collection and filtering on the client, you are able to query from the store exactly the data that you need.


## Building an Offline and Real-Time App with Amplify DataStore

